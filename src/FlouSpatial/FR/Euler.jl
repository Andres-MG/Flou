function rotate2face(Qf, frame, ::EulerEquation{1})
    return SVector(Qf[1], Qf[2] * frame.n[1], Qf[3])
end

function rotate2phys(Qrot, frame, ::EulerEquation{1})
    return SVector(Qrot[1], Qrot[2] * frame.n[1], Qrot[3])
end

function rotate2face(Qf, frame, ::EulerEquation{2})
    (; n, t) = frame
    return SVector(
        Qf[1],
        Qf[2] * n[1] + Qf[3] * n[2],
        Qf[2] * t[1] + Qf[3] * t[2],
        Qf[4],
    )
end

function rotate2phys(Qrot, frame, ::EulerEquation{2})
    (; n, t) = frame
    return SVector(
        Qrot[1],
        Qrot[2] * n[1] + Qrot[3] * t[1],
        Qrot[2] * n[2] + Qrot[3] * t[2],
        Qrot[4],
    )
end

function rotate2face(Qf, frame, ::EulerEquation{3})
    (; n, t, b) = frame
    return SVector(
        Qf[1],
        Qf[2] * n[1] + Qf[3] * n[2] + Qf[4] * n[3],
        Qf[2] * t[1] + Qf[3] * t[2] + Qf[4] * t[3],
        Qf[2] * b[1] + Qf[3] * b[2] + Qf[4] * b[3],
        Qf[5],
    )
end

function rotate2phys(Qrot, frame, ::EulerEquation{3})
    (; n, t, b) = frame
    return SVector(
        Qrot[1],
        Qrot[2] * n[1] + Qrot[3] * t[1] + Qrot[4] * b[1],
        Qrot[2] * n[2] + Qrot[3] * t[2] + Qrot[4] * b[2],
        Qrot[2] * n[3] + Qrot[3] * t[3] + Qrot[4] * b[3],
        Qrot[5],
    )
end

#==========================================================================================#
#                                   Boundary Conditions                                    #

struct EulerInflowBC{RT,NV} <: AbstractBC
    Qext::SVector{NV,RT}
    function EulerInflowBC(Qext)
        nvar = length(Qext)
        3 <= nvar <= 5 || throw(ArgumentError("`Qext` must have a length of 3, 4 or 5."))
        return new{eltype(Qext),nvar}(SVector{nvar}(Qext))
    end
end

function (bc::EulerInflowBC)(_, _, _, _, ::EulerEquation)
    return bc.Qext
end

struct EulerOutflowBC <: AbstractBC end

function (::EulerOutflowBC)(Qin, _, _, _, eq::EulerEquation)
    return SVector{nvariables(eq)}(Qin)
end

struct EulerSlipBC <: AbstractBC end

function (::EulerSlipBC)(Qin, _, frame, _, eq::EulerEquation)
    Qn = rotate2face(Qin, frame, eq) |> MVector
    Qn[2] = -Qn[2]
    return rotate2phys(SVector(Qn), frame, eq)
end

#==========================================================================================#
#                                     Numerical fluxes                                     #

function numericalflux(
    Ql,
    Qr,
    _,
    eq::EulerEquation{ND},
    ::StdAverageNumericalFlux,
) where {
    ND,
}
    if ND == 1
        _, œÅul, œÅel = Ql
        _, œÅur, œÅer = Qr
        _, ul, pl = vars_cons2prim(Ql, eq)
        _, ur, pr = vars_cons2prim(Qr, eq)
        return SVector(
            (œÅul + œÅur) / 2,
            (œÅul * ul + pl + œÅur * ur + pr) / 2,
            ((œÅel + pl) * ul + (œÅer + pr) * ur) / 2,
        )

    elseif ND == 2
        _, œÅul, œÅvl, œÅel = Ql
        _, œÅur, œÅvr, œÅer = Qr
        _, ul, _, pl = vars_cons2prim(Ql, eq)
        _, ur, _, pr = vars_cons2prim(Qr, eq)
        return SVector(
            (œÅul + œÅur) / 2,
            (œÅul * ul + pl + œÅur * ur + pr) / 2,
            (œÅvl * ul + œÅvr * ur) / 2,
            ((œÅel + pl) * ul + (œÅer + pr) * ur) / 2,
        )

    else # ND == 3
        _, œÅul, œÅvl, œÅwl, œÅel = Ql
        _, œÅur, œÅvr, œÅwr, œÅer = Qr
        _, ul, _, _, pl = vars_cons2prim(Ql, eq)
        _, ur, _, _, pr = vars_cons2prim(Qr, eq)
        return SVector(
            (œÅul + œÅur) / 2,
            (œÅul * ul + pl + œÅur * ur + pr) / 2,
            (œÅvl * ul + œÅvr * ur) / 2,
            (œÅwl * ul + œÅwr * ur) / 2,
            ((œÅel + pl) * ul + (œÅer + pr) * ur) / 2,
        )
    end
end

function numericalflux(
    Ql,
    Qr,
    n,
    eq::EulerEquation{ND},
    nf::LxFNumericalFlux,
) where {
    ND,
}
    # Average
    Fn = numericalflux(Ql, Qr, n, eq, nf.avg)

    # Dissipation
    if ND == 1
        œÅl, ul, pl = vars_cons2prim(Ql, eq)
        œÅr, ur, pr = vars_cons2prim(Qr, eq)
    elseif ND == 2
        œÅl, ul, _, pl = vars_cons2prim(Ql, eq)
        œÅr, ur, _, pr = vars_cons2prim(Qr, eq)
    else # ND == 3
        œÅl, ul, _, _, pl = vars_cons2prim(Ql, eq)
        œÅr, ur, _, _, pr = vars_cons2prim(Qr, eq)
    end
    al = soundvelocity(œÅl, pl, eq)
    ar = soundvelocity(œÅr, pr, eq)
    Œª = max(abs(ul) + al, abs(ur) + ar)
    return SVector(Fn + Œª * (Ql - Qr) / 2 * nf.intensity)
end

struct ChandrasekharAverage <: AbstractNumericalFlux end

function numericalflux(
    Ql,
    Qr,
    _,
    eq::EulerEquation{ND},
    ::ChandrasekharAverage,
) where {
    ND,
}
    # Variables
    if ND == 1
        œÅl, ul, pl = vars_cons2prim(Ql, eq)
        œÅr, ur, pr = vars_cons2prim(Qr, eq)
        u = (ul + ur) / 2
    elseif ND == 2
        œÅl, ul, vl, pl = vars_cons2prim(Ql, eq)
        œÅr, ur, vr, pr = vars_cons2prim(Qr, eq)
        u, v = (ul + ur) / 2, (vl + vr) / 2
    else # ND == 3
        œÅl, ul, vl, wl, pl = vars_cons2prim(Ql, eq)
        œÅr, ur, vr, wr, pr = vars_cons2prim(Qr, eq)
        u, v, w = (ul + ur) / 2, (vl + vr) / 2, (wl + wr) / 2
    end

    # Averages
    Œ≤l, Œ≤r = œÅl / 2pl, œÅr / 2pr
    œÅ = logarithmic_mean(œÅl, œÅr)
    p = (œÅl + œÅr) / (2 * (Œ≤l + Œ≤r))
    Œ≤ = logarithmic_mean(Œ≤l, Œ≤r)

    # Fluxes
    if ND == 1
        h = 1 / (2Œ≤ * (eq.Œ≥ - 1)) - (ul^2 + ur^2) / 4 + p/œÅ + u^2
        return SVector(
            œÅ * u,
            œÅ * u^2 + p,
            œÅ * u * h,
        )
    elseif ND == 2
        h = 1 / (2Œ≤ * (eq.Œ≥ - 1)) - (ul^2 + vl^2 + ur^2 + vr^2) / 4 + p/œÅ + u^2 + v^2
        return SVector(
            œÅ * u,
            œÅ * u^2 + p,
            œÅ * u * v,
            œÅ * u * h,
        )
    else # ND == 3
        h = 1 / (2Œ≤ * (eq.Œ≥ - 1)) - (ul^2 + vl^2 + wl^2 + ur^2 + vr^2 + wl^2) / 4 +
            p/œÅ + u^2 + v^2 + w^2
        return SVector(
            œÅ * u,
            œÅ * u^2 + p,
            œÅ * u * v,
            œÅ * u * w,
            œÅ * u * h,
        )
    end
end

struct ScalarDissipation{T,RT} <: AbstractNumericalFlux
    avg::T
    intensity::RT
end

function numericalflux(
    Ql,
    Qr,
    n,
    eq::EulerEquation{ND},
    nf::ScalarDissipation,
) where {
    ND,
}
    # Variables
    if ND == 1
        œÅl, ul, pl = vars_cons2prim(Ql, eq)
        œÅul = Ql[2]
        œÅr, ur, pr = vars_cons2prim(Qr, eq)
        œÅur = Qr[2]
        u = (ul + ur) / 2
    elseif ND == 2
        œÅl, ul, vl, pl = vars_cons2prim(Ql, eq)
        œÅul, œÅvl = Ql[2], Ql[3]
        œÅr, ur, vr, pr = vars_cons2prim(Qr, eq)
        œÅur, œÅvr = Qr[2], Qr[3]
        u, v = (ul + ur) / 2, (vl + vr) / 2
    else # ND == 3
        œÅl, ul, vl, wl, pl = vars_cons2prim(Ql, eq)
        œÅul, œÅvl, œÅwl = Qr[2], Qr[3], Qr[4]
        œÅr, ur, vr, wr, pr = vars_cons2prim(Qr, eq)
        œÅur, œÅvr, œÅwr = Qr[2], Qr[3], Qr[4]
        u, v, w = (ul + ur) / 2, (vl + vr) / 2, (wl + wr) / 2
    end

    # Averages
    œÅ = (œÅl + œÅr) / 2
    Œ≤l, Œ≤r = œÅl / 2pl, œÅr / 2pr
    Œ≤ = logarithmic_mean(Œ≤l, Œ≤r)
    al = soundvelocity(œÅl, pl, eq)
    ar = soundvelocity(œÅr, pr, eq)

    # Averaging term
    Fn = numericalflux(Ql, Qr, n, eq, nf.avg)

    # Dissipative term
    Œª = max(abs(ul) + al, abs(ur) + ar)
    ùìì = if ND == 1
        SVector(
            œÅr - œÅl,
            œÅur - œÅul,
            (1 / Œ≤ / (eq.Œ≥ - 1) + ul * ur) * (œÅr - œÅl) / 2 +
                œÅ * (u * (ur - ul) + (1/Œ≤r - 1/Œ≤l) / 2(eq.Œ≥ - 1)),
        )
    elseif ND == 2
        SVector(
            œÅr - œÅl,
            œÅur - œÅul,
            œÅvr - œÅvl,
            (1 / Œ≤ / (eq.Œ≥ - 1) + ul * ur + vl * vr) * (œÅr - œÅl) / 2 +
                œÅ * (u * (ur - ul) + v * (vr - vl) + (1/Œ≤r - 1/Œ≤l) / 2(eq.Œ≥ - 1)),
        )
    else # ND == 3
        SVector(
            œÅr - œÅl,
            œÅur - œÅul,
            œÅvr - œÅvl,
            œÅwr - œÅwl,
            (1 / Œ≤ / (eq.Œ≥ - 1) + ul * ur + vl * vr + wl * wr) * (œÅr - œÅl) / 2 +
                œÅ * (u * (ur - ul) + v * (vr - vl) + w * (wr - wl) + (1/Œ≤r - 1/Œ≤l) / 2(eq.Œ≥ - 1)),
        )
    end
    return SVector(Fn - Œª / 2 * ùìì * nf.intensity)
end

struct MatrixDissipation{T,RT} <: AbstractNumericalFlux
    avg::T
    intensity::RT
end

function numericalflux(
    Ql,
    Qr,
    n,
    eq::EulerEquation{ND},
    nf::MatrixDissipation,
) where {
    ND,
}
    # Variables
    if ND == 1
        œÅl, ul, pl = vars_cons2prim(Ql, eq)
        œÅr, ur, pr = vars_cons2prim(Qr, eq)
        u = (ul + ur) / 2
        v2 = 2 * u^2 - (ul^2 + ur^2) / 2
    elseif ND == 2
        œÅl, ul, vl, pl = vars_cons2prim(Ql, eq)
        œÅr, ur, vr, pr = vars_cons2prim(Qr, eq)
        u, v = (ul + ur) / 2, (vl + vr) / 2
        v2 = 2 * (u^2 + v^2) - (ul^2 + vl^2 + ur^2 + vr^2) / 2
    else # ND == 3
        œÅl, ul, vl, wl, pl = vars_cons2prim(Ql, eq)
        œÅr, ur, vr, wr, pr = vars_cons2prim(Qr, eq)
        u, v, w = (ul + ur) / 2, (vl + vr) / 2, (wl + wr) / 2
        v2 = 2 * (u^2 + v^2 + w^2) - (ul^2 + vl^2 + wl^2 + ur^2 + vr^2 + wr^2) / 2
    end

    # Averages
    Œ≤l, Œ≤r = œÅl / 2pl, œÅr / 2pr
    œÅ = logarithmic_mean(œÅl, œÅr)
    p = (œÅl + œÅr) / (2 * (Œ≤l + Œ≤r))
    Œ≤ = logarithmic_mean(Œ≤l, Œ≤r)
    a = soundvelocity(œÅ, p, eq)
    h = eq.Œ≥ / 2Œ≤ / (eq.Œ≥ - 1) + v2 / 2

    # Averaging term
    Fn = numericalflux(Ql, Qr, n, eq, nf.avg)

    # Dissipative term
    rt = eltype(Fn)
    Wl = vars_cons2entropy(Ql, eq)
    Wr = vars_cons2entropy(Qr, eq)

    if ND == 1
        Œõ = SDiagonal{3}((u - a, u, u + a) .|> abs)
        T = SDiagonal{3}((œÅ / 2eq.Œ≥, (eq.Œ≥ - 1) * œÅ / eq.Œ≥, œÅ / 2eq.Œ≥))
        R = SMatrix{3,3}(
            one(rt),  u - a, h - u * a,
            one(rt),  u,     v2 / 2,
            one(rt),  u + a, h + u * a,
        )
    elseif ND == 2
        Œõ = SDiagonal{4}((u - a, u, u, u + a) .|> abs)
        T = SDiagonal{4}((œÅ / 2eq.Œ≥, (eq.Œ≥ - 1) * œÅ / eq.Œ≥, p, œÅ / 2eq.Œ≥))
        R = SMatrix{4,4}(
            one(rt),  u - a,    v,       h - u * a,
            one(rt),  u,        v,       v2 / 2,
            zero(rt), zero(rt), one(rt), v,
            one(rt),  u + a,    v,       h + u * a,
        )
    else # ND == 3
        Œõ = SDiagonal{5}((u - a, u, u, u, u + a) .|> abs)
        T = SDiagonal{5}((œÅ / 2eq.Œ≥, (eq.Œ≥ - 1) * œÅ / eq.Œ≥, p, p, œÅ / 2eq.Œ≥))
        R = SMatrix{5,5}(
            one(rt),  u - a,    v,        w,        h - u * a,
            one(rt),  u,        v,        w,        v2 / 2,
            zero(rt), zero(rt), one(rt),  zero(rt), v,
            zero(rt), zero(rt), zero(rt), one(rt),  w,
            one(rt),  u + a,    v,        w,        h + u * a,
        )
    end
    return SVector(Fn + R * Œõ * T * R' * (Wl - Wr) / 2 * nf.intensity)
end

#==========================================================================================#
#                                     Two-point fluxes                                     #

function twopointflux(
    Q1,
    Q2,
    Ja1,
    Ja2,
    eq::EulerEquation{ND},
    ::ChandrasekharAverage,
) where {
    ND,
}
    # Variables
    if ND == 1
        œÅ1, u1, p1 = vars_cons2prim(Q1, eq)
        œÅ2, u2, p2 = vars_cons2prim(Q2, eq)
        u = (u1 + u2) / 2
    elseif ND == 2
        œÅ1, u1, v1, p1 = vars_cons2prim(Q1, eq)
        œÅ2, u2, v2, p2 = vars_cons2prim(Q2, eq)
        u, v = (u1 + u2) / 2, (v1 + v2) / 2
    else # ND == 3
        œÅ1, u1, v1, w1, p1 = vars_cons2prim(Q1, eq)
        œÅ2, u2, v2, w2, p2 = vars_cons2prim(Q2, eq)
        u, v, w = (u1 + u2) / 2, (v1 + v2) / 2, (w1 + w2) / 2
    end

    # Averages
    Œ≤1, Œ≤2 = œÅ1 / 2p1, œÅ2 / 2p2
    œÅ = logarithmic_mean(œÅ1, œÅ2)
    p = (œÅ1 + œÅ2) / (2 * (Œ≤1 + Œ≤2))
    Œ≤ = logarithmic_mean(Œ≤1, Œ≤2)

    # Fluxes
    if ND == 1
        h = 1 / (2Œ≤ * (eq.Œ≥ - 1)) - (u1^2 + u2^2) / 4 + p/œÅ + u^2
        n = (Ja1[1] + Ja2[1]) / 2
        return SVector(
            (œÅ * u) * n,
            (œÅ * u^2 + p) * n,
            (œÅ * u * h) * n,
        )
    elseif ND == 2
        h = 1 / (2Œ≤ * (eq.Œ≥ - 1)) - (u1^2 + v1^2 + u2^2 + v2^2) / 4 + p/œÅ + u^2 + v^2
        n = SVector((Ja1 .+ Ja2) ./ 2)
        return SVector(
            (œÅ * u) * n[1] + (œÅ * v) * n[2],
            (œÅ * u^2 + p) * n[1] + (œÅ * u * v) * n[2],
            (œÅ * u * v) * n[1] + (œÅ * v^2 + p) * n[2],
            (œÅ * u * h) * n[1] + (œÅ * v * h) * n[2],
        )
    else # ND == 3
        h = 1 / (2Œ≤ * (eq.Œ≥ - 1)) - (u1^2 + v1^2 + w1^2 + u2^2 + v2^2 + w2^2) / 4 +
            p/œÅ + u^2 + v^2 + w^2
        n = SVector((Ja1 .+ Ja2) ./ 2)
        return SVector(
            (œÅ * u) * n[1] + (œÅ * v) * n[2] + (œÅ * w) * n[3],
            (œÅ * u^2 + p) * n[1] + (œÅ * u * v) * n[2] + (œÅ * u * w) * n[3],
            (œÅ * u * v) * n[1] + (œÅ * v^2 + p) * n[2] + (œÅ * v * w) * n[3],
            (œÅ * u * w) * n[1] + (œÅ * v * w) * n[2] + (œÅ * w^2 + p) * n[3],
            (œÅ * u * h) * n[1] + (œÅ * v * h) * n[2] + (œÅ * w * h) * n[3],
        )
    end
    return nothing
end

#==========================================================================================#
#                                    Monitors                                              #

function FlouCommon.list_monitors(::FR, ::EulerEquation)
    return (:kinetic_energy, :entropy,)
end

function FlouCommon.get_monitor(dg::FR, equation::EulerEquation, name::Symbol, _)
    if name == :energy
        return kinetic_energy_monitor(dg, equation)
    elseif name == :entropy
        return entropy_monitor(dg, equation)
    else
        error("Unknown monitor '$(name)'.")
    end
end

function kinetic_energy_monitor(dg::FR, ::EulerEquation)
    monitor = (Q, dg, equation) -> begin
        s = zero(eltype(Q))
        @flouthreads for ie in eachelement(dg)
            svec = dg.std.cache.scalar[Threads.threadid()][1]
            @inbounds for i in eachindex(svec)
                svec[i] = kinetic_energy(Q.element[ie][i], equation)
            end
            s += integrate(svec, dg.geometry.elements[ie])
        end
        return s
    end
    return (datatype(dg), monitor)
end

function entropy_monitor(dg::FR, ::EulerEquation)
    monitor = (Q, dg, equation) -> begin
        s = zero(eltype(Q))
        @flouthreads for ie in eachelement(dg)
            svec = dg.std.cache.scalar[Threads.threadid()][1]
            @inbounds for i in eachindex(svec)
                svec[i] = math_entropy(Q.element[ie][i], equation)
            end
            s += integrate(svec, dg.geometry.elements[ie])
        end
        return s
    end
    return (datatype(dg), monitor)
end
