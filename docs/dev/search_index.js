var documenterSearchIndex = {"docs":
[{"location":"devs/#Developers","page":"Developers","title":"Developers","text":"","category":"section"},{"location":"devs/#Standard-regions-–-StdRegions.jl","page":"Developers","title":"Standard regions – StdRegions.jl","text":"","category":"section"},{"location":"devs/","page":"Developers","title":"Developers","text":"Any standard region extending the AbstractStdRegion struct must implement the is_tensor_product trait. The idea behind is to use the tensor product structure of the nodes to employ a faster approach.","category":"page"},{"location":"devs/","page":"Developers","title":"Developers","text":"is_tensor_product","category":"page"},{"location":"devs/#Index","page":"Developers","title":"Index","text":"","category":"section"},{"location":"devs/","page":"Developers","title":"Developers","text":"","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = Flou","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Flou is a solver for hyperbolic partial differential equations, using a flux reconstruction approach.","category":"page"},{"location":"#Hyperbolic-equations","page":"Introduction","title":"Hyperbolic equations","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Equations of this type represent conservation laws: boldsymbolq_t + nablacdotvecboldsymbolf = boldsymbols, where the integral values of boldsymbolq are only modified by the fluxes through the boundaries or the sources/drains represented by boldsymbols.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The numerical resolution of this equations requires the discretization of the variables, i.e. the components of boldsymbolq and the time, t. We rely on DifferentialEquations.jl for the temporal term, and Flou provides different spatial discretizations that can be directly integrated in time.","category":"page"},{"location":"#Flux-reconstruction-(FR)","page":"Introduction","title":"Flux reconstruction (FR)","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Starting with the 1D version of a generic conservation law, q_t + f_x = s, defined on a certain region of the space, this domain is subdivided in non-overlapping elements. Inside them we represent the spatial distribution of any magnitude as a linear combination of a set of nodal functions, phi_i(x),","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"q approx sum_i=0^n q_i phi_i(x) quad phi_i(x_j) = delta_ij","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The fluxes require a little bit more of work. Since they appear in the equation as a derivative, its function approximation must be consistent with the approximation of the rest of the terms. This means that if phi_i(x) in mathbbP^n, the fluxes should be approximated with a different basis that, when derived, contains phi_i(x)_i,","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"f approx sum_i=0^m f_i psi_i(x) quad psi_i(x_j) = delta_ij","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Considering this, and since we are seeking the time derivative of q_i at the different solution points x_0 dots x_n, the discretization would be as follows,","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"J_i(q_t)_i approx -sum_j=0^m f_j psi_j(x_i) + s(x_i) quad i = 0 dots n","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Now we recall that our spatial domain is divided in a set of elements, and we have not imposed that the appoximations inside our elements are continous. In general, the numerical solution that we obtain with these methods is not continuous accross elements. However, information must be able to travel throughout the domain and we introduce this in our mathematical discretization with numerical fluxes, f^star. They act on two different states, q_l and q_r, and return a sort of \"common\" flux by approximating the Riemann problem defined by the discontinuity between q_l and q_r.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We use this at the element interfaces, so that the information arriving at one of the element boundaries is transmited by means of the discontinuity that it creates. To apply this to our numerical discretization, we first compute the values of q at a new set of points, xi_0 dots xi_m that includes the boundaries, xi=-1 xi=1. We compute the fluxes there as f_i = f(xi_i) = f(q(xi_i)) and also use the values of q at the boundaries to obtain f^star_l and f^star_r. We are now ready to represent the approximation of the flux taking into account the neighbouring elements,","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"f approx sum_i=0^m f_i psi_i(x) + left(f^star_l - sum_i=0^m f_i psi_i(-1)right)g_l(x) + left(f^star_r - sum_i=0^m f_i psi_i(+1)right)g_r(x)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The functions g_l(x) and g_r(x) are called reconstruction functions and there are several options. They are simply required to be valued 1 on \"their\" side and 0 on the other. In the next chapters we will see that other spatial discretizations can be recasted into the flux reconstruction framework by a certain choice of reconstruction functions. Finally, the FR spatial discretization is,","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"J_i(q_t)_i approx -sum_j=0^m f_j psi_j(x_i) + left(f^star_l - sum_i=0^m f_i psi_i(-1)right)leftfracdg_ldxrightrvert_x_i + left(f^star_r - sum_i=0^m f_i psi_i(+1)right)leftfracdg_rdxrightrvert_x_i + s(x_i)","category":"page"},{"location":"#Discontinuous-Galerkin-Spectral-Element-Method-(DGSEM)","page":"Introduction","title":"Discontinuous Galerkin Spectral Element Method (DGSEM)","text":"","category":"section"},{"location":"#Extension-to-higher-dimensions-in-tensor-product-elements","page":"Introduction","title":"Extension to higher dimensions in tensor-product elements","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Weak form in 2D for tensor-product elements:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"M dotboldsymbolQ_ij = sum_k^N_x K^(j)_xik tildeboldsymbolf_kj + sum_k^N_y K^(i)_yjk tildeboldsymbolg_ik - sum_d^2 L_omega_xij^(d) boldsymbolf_ni^star - sum_d^2 L_omega_yij^(d) boldsymbolg_nj^star","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Strong form in 2D for tensor-product elements:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"M dotboldsymbolQ_ij = sum_k^N_x hatK^(j)_xik tildeboldsymbolf_kj + sum_k^N_y hatK^(i)_yjk tildeboldsymbolg_ik - sum_d^2 L_omega_xj^(d) boldsymbolf_ni^star - sum_d^2 L_omega_yij^(d) boldsymbolg_nj^star","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The matrices are defined as follows:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"begingathered\nM = textdiag(J_ijomega_xiomega_yj) \nK^(j)_xik = omega_yjomega_xkD_xki \nK^(i)_yjk = omega_xiomega_ykD_ykj \nhatK^(j)_xik = -omega_yjomega_xiD_xik + omega_yjleftl_xi(1)l_xk(1) - l_xi(-1)l_xk(-1)right \nhatK^(i)_yjk = -omega_xiomega_yjD_yjk + omega_xileftl_yj(1)l_yk(1) - l_yj(-1)l_yk(-1)right \nL_omega_xij^(1) = omega_yjl_xi(-1) \nL_omega_xij^(2) = omega_yjl_xi(1) \nL_omega_yij^(1) = omega_xil_yj(-1) \nL_omega_yij^(2) = omega_xil_yj(1)\nendgathered","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nNotice that the operators in 2D are very similar to the ones in 1D. They are simply the tensor product of their 1D versions with the vector vecomega corresponding to the other direction. For example, K^text2D_x = K^text1D_x otimes omega_y, which is a third order tensor with size N_x times N_x times N_y.","category":"page"},{"location":"#Divergence-operators","page":"Introduction","title":"Divergence operators","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Modules = [Flou.FlouSpatial]\nPages = [\"OpDivergence.jl\"]","category":"page"},{"location":"#Flou.FlouSpatial.SSFVDivOperator","page":"Introduction","title":"Flou.FlouSpatial.SSFVDivOperator","text":"SSFVDivOperator([tpflux=numflux.avg, [fvflux=numflux]], numflux, blend)\n\nSplit-divergence operator in telescopic form. Only implemented for tensor-product elements.\n\nThe telescopic operator approach effectively turns the initial split formulation into a sub-element finite volume scheme. The twopointflux and fvflux are both combined into an entropy-stable interface flux that controls the volume dissipation through the subcell interface Riemann solver.\n\n\n\n\n\n","category":"type"},{"location":"#Flou.FlouSpatial.SplitDivOperator","page":"Introduction","title":"Flou.FlouSpatial.SplitDivOperator","text":"SplitDivOperator([tpflux=numflux.avg], numflux)\n\nSplit-divergence operator, only implemented for tensor-product elements. The two-point flux represents the splitting strategy.\n\n\n\n\n\n","category":"type"},{"location":"#Flou.FlouSpatial.requires_subgrid-Tuple{Flou.FlouSpatial.AbstractDivOperator, Flou.FlouSpatial.AbstractStdRegion}","page":"Introduction","title":"Flou.FlouSpatial.requires_subgrid","text":"requires_subgrid(divergence, std)\n\nReturn true if the specified divergence operator needs the allocation of the subcell grid.\n\n\n\n\n\n","category":"method"}]
}
